import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { DatabaseService } from './database.service';


interface DailyForecast {
  date: string;
  temp: number;
  description: string;
}

@Injectable()
export class WeatherService {
  constructor(
    private configService: ConfigService,
    private db: DatabaseService,
  ) {}

  async getWeather(city: string) {
    if (!city) return { error: 'City is required.' };

    const apiKey = this.configService.get('OPENWEATHER_API_KEY');
    const encodedCity = encodeURIComponent(city);

    // === Fetch current weather ===
    const currentUrl = `https://api.openweathermap.org/data/2.5/weather?q=${encodedCity}&appid=${apiKey}&units=metric`;
    const currentRes = await fetch(currentUrl);
    const currentData = await currentRes.json();

    if (currentData.cod !== 200) {
      return { error: currentData.message || 'City not found.' };
    }

    // Save search to database
    await this.db.addSearch(city);

    // === Fetch 5-day forecast ===
    const forecastUrl = `https://api.openweathermap.org/data/2.5/forecast?q=${encodedCity}&appid=${apiKey}&units=metric`;
    const forecastRes = await fetch(forecastUrl);
    const forecastData = await forecastRes.json();

    if (forecastData.cod !== '200') {
      return { error: forecastData.message || 'Forecast not available.' };
    }

    // === Process and group forecast data ===
    const seenDates = new Set<string>();
    const dailyForecasts: DailyForecast[] = [];

    for (const entry of forecastData.list) {
      const dateOnly = entry.dt_txt.split(' ')[0];
      if (!seenDates.has(dateOnly)) {
        seenDates.add(dateOnly);
        dailyForecasts.push({
          date: entry.dt_txt,
          temp: entry.main.temp,
          description: entry.weather[0].description,
        });
      }
      if (dailyForecasts.length === 5) break;
    }

    // === Replace today's forecast (index 0) with the current live data ===
    if (dailyForecasts.length > 0) {
      dailyForecasts[0] = {
        date: new Date().toISOString().split('T')[0],
        temp: currentData.main.temp,
        description: currentData.weather[0].description,
      };
    }

    // === Return structured response ===
    return {
      city: currentData.name,
      current: {
        temperature: currentData.main.temp,
        description: currentData.weather[0].description,
        feels_like: currentData.main.feels_like,
        humidity: currentData.main.humidity,
        wind_speed: currentData.wind.speed,
      },
      forecast: dailyForecasts,
    };
  }

  async getSearchHistory() {
    return this.db.getRecentSearches();
  }
}
